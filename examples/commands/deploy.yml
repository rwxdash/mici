# An example written by AI based on the structure decided in ./schemas/v1.rs
version: 1
name: Deployment Pipeline
description: "Enhanced deployment pipeline showing command vs script patterns"

inputs:
  environment:
    type: choice
    description: "Target environment"
    options: [staging, production]
    required: true
    short: -e

  service:
    type: string
    description: "Service to deploy"
    required: true
    short: -s

  force:
    type: boolean
    description: "Force deployment even if tests fail"
    short: -f

  dry_run:
    type: boolean
    description: "Show what would be deployed without doing it"
    long: --dry-run

  version:
    type: string
    description: "Version tag to deploy"
    default: "latest"

configuration:
  confirm: true
  environment:
    DEPLOY_USER: "${env.USER}"
    TIMESTAMP: "${env.DATE}"

steps:
  # COMMAND pattern - when you need inline logic and explicit control
  - name: "Pre-deployment Validation"
    run:
      shell: /bin/bash
      command: |
        echo "ðŸ” Validating deployment for ${inputs.service} to ${inputs.environment}"

        if [[ "${inputs.environment}" == "production" && "${inputs.dry_run}" != "true" ]]; then
          echo "âš ï¸  Production deployment detected!"
          echo "Service: ${inputs.service}"
          echo "Version: ${inputs.version}"
          echo "Force mode: ${inputs.force}"

          # Custom validation logic
          if ! kubectl get namespace "${inputs.service}-${inputs.environment}" >/dev/null 2>&1; then
            echo "âŒ Namespace ${inputs.service}-${inputs.environment} doesn't exist"
            exit 1
          fi
        fi

        echo "âœ… Validation passed"

  # COMMAND pattern - complex pipeline with mixed tools
  - name: "Build and Test"
    run:
      shell: /bin/bash
      environment:
        BUILD_ENV: "${inputs.environment}"
      command: |
        echo "ðŸ—ï¸  Building ${inputs.service} for ${inputs.environment}"

        # Build the application
        docker build -t "${inputs.service}:${inputs.version}" .

        # Run tests unless forced to skip
        if [[ "${inputs.force}" != "true" ]]; then
          echo "ðŸ§ª Running tests..."
          ${scripts/run-tests.sh} --service "${inputs.service}" --env "${inputs.environment}"

          if [[ $? -ne 0 ]]; then
            echo "âŒ Tests failed!"
            exit 1
          fi
        else
          echo "âš ï¸  Skipping tests (forced deployment)"
        fi

        echo "âœ… Build completed"

  # SCRIPT pattern - clean, focused, reusable
  - name: "Deploy Infrastructure"
    run:
      script: deploy-infrastructure.py
      shell: python3
      # Auto-passes: --environment staging --service myapp --force --version latest
      environment:
        DEPLOY_MODE: "infrastructure"

  # SCRIPT pattern with selective args - only what the script needs
  - name: "Deploy Application"
    run:
      script: deploy-app.sh
      args:
        - environment
        - service
        - version
        # Note: force and dry_run are NOT passed
      environment:
        KUBECTL_CONTEXT: "${inputs.environment}-cluster"

  # SCRIPT pattern with custom mapping - reshape the interface
  - name: "Update Service Mesh"
    run:
      script: update-mesh.rb
      shell: ruby
      args:
        target_env: "${inputs.environment}" # Rename environment -> target_env
        app_name: "${inputs.service}" # Rename service -> app_name
        release_tag: "${inputs.version}" # Rename version -> release_tag
        skip_validation: "${inputs.force}" # Rename force -> skip_validation
        preview_mode: "${inputs.dry_run}" # Rename dry_run -> preview_mode

  # COMMAND pattern - when you need conditional logic and custom flow
  - name: "Database Migration"
    when: "${inputs.environment}" # Only run for production/staging, not dry runs
    run:
      shell: /bin/bash
      command: |
        if [[ "${inputs.dry_run}" == "true" ]]; then
          echo "ðŸ”„ Would run database migrations for ${inputs.service}"
          ${scripts/migration-preview.sh} "${inputs.service}" "${inputs.environment}"
        else
          echo "ðŸ”„ Running database migrations..."

          # Pre-migration backup
          ${scripts/backup-db.sh} --service "${inputs.service}" --env "${inputs.environment}"

          # Run migrations with error handling
          if ! ${scripts/migrate.sh} --service "${inputs.service}" --env "${inputs.environment}"; then
            echo "âŒ Migration failed! Rolling back..."
            ${scripts/restore-db.sh} --service "${inputs.service}" --env "${inputs.environment}"
            exit 1
          fi

          echo "âœ… Migration completed"
        fi

  # SCRIPT pattern - simple, clean notification
  - name: "Send Deployment Notification"
    run:
      script: notify.js
      shell: node
      # Gets all args automatically, script can ignore what it doesn't need

  # COMMAND pattern - complex cleanup with conditional logic
  - name: "Cleanup"
    run:
      always: true # Always run, even if previous steps failed
      shell: /bin/bash
      command: |
        echo "ðŸ§¹ Cleaning up deployment artifacts..."

        # Clean up based on deployment type
        if [[ "${inputs.dry_run}" == "true" ]]; then
          echo "Dry run - no cleanup needed"
        else
          # Remove temporary build artifacts
          docker image prune -f --filter "label=service=${inputs.service}"

          # Clean up failed deployments if any
          kubectl delete pods -l "app=${inputs.service},status=failed" \
            -n "${inputs.service}-${inputs.environment}" 2>/dev/null || true
        fi

        echo "âœ… Cleanup completed"
